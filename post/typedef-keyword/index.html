<!DOCTYPE html>
<html lang='en'><head>
  <title>关键字 typedef 深入了解 | thinkerou</title>
  <meta charset='utf-8'>
  <meta name="generator" content="Hugo 0.71.0" />
  <meta name = 'viewport' content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'>
  <meta http-equiv = 'X-UA-Compatible' content = 'IE=edge'>
<meta property = 'og:locale' content = 'en_US' />
<meta property="og:type" content="article">
<meta property = 'og:title' content = '关键字 typedef 深入了解' />
<meta name="description" content="引子：几行代码 为了不浪费时间，先来看看如下三行代码：
typedef int arr[10]; typedef void (*pf)(); typedef int* (*pf)(int* (p*)(int*, int*), int*);  如果能准确知道上面三行代码的意义，我想就没有必要继续往下看了，当然，为了温习也 …">
<meta property = 'og:description' content = '引子：几行代码 为了不浪费时间，先来看看如下三行代码：
typedef int arr[10]; typedef void (*pf)(); typedef int* (*pf)(int* (p*)(int*, int*), int*);  如果能准确知道上面三行代码的意义，我想就没有必要继续往下看了，当然，为了温习也 …'>
<meta property = 'og:url' content = 'https://thinkerou.com/post/typedef-keyword/' />
<meta property = 'og:image' content = 'https://thinkerou.com/images/artist.jpg'/>
<meta name = 'twitter:card' content = 'summary_large_image' />
<meta name = 'twitter:creator' content = ''>
<meta name = 'twitter:title' content = '关键字 typedef 深入了解' />
<meta property = 'twitter:description'  content = '引子：几行代码 为了不浪费时间，先来看看如下三行代码：
typedef int arr[10]; typedef void (*pf)(); typedef int* (*pf)(int* (p*)(int*, int*), int*);  如果能准确知道上面三行代码的意义，我想就没有必要继续往下看了，当然，为了温习也 …'/>
<meta name = 'twitter:image' content = 'https://thinkerou.com/images/artist.jpg' />
<link rel='apple-touch-icon' sizes='180x180' href='https://thinkerou.com/images/icons/apple-touch-icon.png'>
<link rel='icon' type='image/png' sizes='32x32' href='https://thinkerou.com/images/icons/favicon-32x32.png'>
<link rel='icon' type='image/png' sizes='16x16' href='https://thinkerou.com/images/icons/favicon-16x16.png'>
<link rel='manifest' href='https://thinkerou.com/images/icons/site.webmanifest'>

  <link rel='canonical' href='https://thinkerou.com/post/typedef-keyword/'>
  <link rel = 'stylesheet' href = 'https://thinkerou.com/css/styles.c96fb35cdb82bc48464011f0651dba456b89bed82175473135ae0ecdd5badc854a5d80ae4f9d8df6b4b90e8d01e9a3c686bb8463c33c66f3bac235102d1c8b32.css' integrity = 'sha512-yW&#43;zXNuCvEhGQBHwZR26RWuJvtghdUcxNa4OzdW63IVKXYCuT52N9rS5Do0B6aPGhruEY8M8ZvO6wjUQLRyLMg=='>
</head>

  <body><div class = 'nav-drop'>
  <div class = 'nav-body'>
      <a href = 'https://thinkerou.com/' class = 'nav_item'>Home</a>
      <a href = 'https://thinkerou.com/about/' class = 'nav_item'>About</a>
      <a href = 'https://thinkerou.com/blog/' class = 'nav_item'>Blog</a>
    <div class = 'nav-close'></div>
  </div>
</div><header class = 'nav' >
  <nav class = 'nav-menu'>
    <a href='https://thinkerou.com/' class = 'nav-brand nav_item'>thinkerou</a>
    <div class = 'nav_bar-wrap'>
      <div class = 'nav_bar'></div>
    </div>
  </nav>
</header>


    <main>
<section class = 'post_header' style = 'background-image:url(https://thinkerou.com/images/artist.jpg);'>
  <h1 class='post_title'>关键字 typedef 深入了解</h1>
</section>
<div class = 'post'>
  <article class='post_content'><h2 id="引子几行代码">引子：几行代码</h2>
<p>为了不浪费时间，先来看看如下三行代码：</p>
<pre><code>typedef int arr[10];
typedef void (*pf)();
typedef int* (*pf)(int* (p*)(int*, int*), int*);
</code></pre>
<p>如果能准确知道上面三行代码的意义，我想就没有必要继续往下看了，当然，为了温习也可以快速阅读。</p>
<h2 id="定义-struct-时-typeder-的含义">定义 struct 时 typeder 的含义</h2>
<h4 id="1-在-c-中定义一个结构体类型需要用-typedef-关键字">1. 在 C 中定义一个结构体类型需要用 typedef 关键字:</h4>
<pre><code>typedef struct TestS
{
    int a;
}Test;
</code></pre>
<p>于是在声明变量时就可以这样：<strong>Test test;</strong> 如果没有 typedef 就必须用 <strong>struct TestS test;</strong> 来声明，这里的 Test 实际上就是 struct TestS 的别名，即 Test == struct TestS。</p>
<p>另外，这里也可以不写 TestS，也就不能 struct TestS test; 了，必须是 Test test;，如下：</p>
<pre><code>typedef struct
{
    int a;
}Test;
</code></pre>
<h4 id="2-在-c-中定义一个结构体类型不再需要用-typedef-关键字">2. 在 C++ 中定义一个结构体类型不再需要用 typedef 关键字:</h4>
<p>在 C++ 里定义一个结构体类型就很简单直接了：</p>
<pre><code>struct TestS
{
    int a;
};
</code></pre>
<p>这样就定义了结构体类型 TestS ，声明变量时直接 <strong>TestS test；</strong> 即可。</p>
<p>但是，在 C++ 中定义结构体时如果使用 typedef 的话又会造成区别：</p>
<pre><code>struct   TestS   
{   
    int a;   
}test; // test是一个变量  

typedef   struct   TestS2   
{   
    int a;   
}test2; // test2是一个结构体类型 == struct TestS2
</code></pre>
<p>使用时可以直接访问 <strong>test.a</strong>，但是 test2 则必须先声明 <strong>test2 s2;</strong>，然后才可操作，如  <strong>s2.a=10;</strong> 。</p>
<h2 id="使用-typedef-声明别名">使用 typedef 声明别名</h2>
<p>关键字 typedef 的一个常见用法是用来声明一个别名，如本文开头的三行代码，形如：</p>
<pre><code>typedef int INT;
</code></pre>
<p>这种形式几乎跟 <strong>#define int INT</strong> 一样。但是并不完全一样！</p>
<p>如果用 #define 的思维来看待 typedef：把 int 与 INT 分开来看，int 是一部分，INT 是另一部分，那么就错了！</p>
<p>实际上根本就不是这么一回事： int 与 INT 是一个整体！就像 int i; 声明一样是一个整体声明，只不过int i 定义了一个变量，而 typedef 定义了一个<strong>别名</strong>。</p>
<p>如果用这种错误的观念来看待 typedef，就会无法理解如下声明：</p>
<pre><code>typedef int a[10];
typedef void (*pf)(void);
</code></pre>
<p>会以为 a[10] 是 int 的别名，(*pf)(void) 是 void 的别名，但这样的别名看起来又似乎不是合法的名字，于是陷入困惑之中。</p>
<p>而实际上，上面的语句把 a 声明为具有 10 个 int 元素的数组的类型别名，pf 是一种函数指针的类型别名。虽然在功能上，typedef 可以看作一个跟 int INT 分离的动作，但语法上 typedef 属于存储类声明说明符，因此严格来说，typedef int INT 是一个完整的声明。</p>
<blockquote>
<p><strong>如何定义一个函数指针类型？</strong></p>
</blockquote>
<blockquote>
<p>如原函数是：</p>
</blockquote>
<blockquote>
<p>void f(int);</p>
</blockquote>
<blockquote>
<p>那么定义的函数指针类型就是：</p>
</blockquote>
<blockquote>
<p>typedef void (*pf)(int);</p>
</blockquote>
<blockquote>
<p>然后用此类型生成一个指向函数的指针：</p>
</blockquote>
<blockquote>
<p>pf func;</p>
</blockquote>
<blockquote>
<p>当 func 获取函数地址之后，就可以像调用原函数那样来使用这个函数指针：<strong>func(int);</strong> 。</p>
</blockquote>
<h2 id="深入理解-typedef">深入理解 typedef</h2>
<h4 id="1-确定被声明的类型">1. 确定被声明的类型</h4>
<p>在遇到 typedef 时，<strong>从左到右进行扫描</strong>，找到<strong>第一个</strong>“陌生”的标识符，这个标识符就应该是语句所声明的类型名称。例如：</p>
<pre><code>typedef int* (*pt)(int* (*pn)(int* p1, int*p2), int* p3);
</code></pre>
<p>如果 pt 是“陌生”标识符（既不是保留字，也不是声明过的类型），那么它就是要声明的类型。其它的名字都是为了阅读方便的占位符，可有可无。也就是说，上面的语句等价为：</p>
<pre><code>typedef int* (*pt)(int* (*)(int*, int*), int*);
</code></pre>
<h4 id="2-如何使用-typedef">2. 如何使用 typedef</h4>
<p>以后一旦遇到该类型声明的变量，则在该类型的 typedef 式中用变量代替类型，去掉typedef关键字，所得到的声明式等价于原来的声明，例如：</p>
<pre><code>pt p；
</code></pre>
<p>该声明式经过两步变化为等价的声明式：</p>
<p>首先，回到 pt 的 typedef 式：</p>
<pre><code>typedef int* (*pt)(int* (*)(int*, int*), int*);
</code></pre>
<p>然后，用 p 代替 pt：</p>
<pre><code>typedef int* (*p)(int* (*)(int*, int*), int*);
</code></pre>
<p>最后，把 typedef 去掉，得到：</p>
<pre><code>int* (*p)(int* (*)(int*, int*), int*);
</code></pre>
<p>这个语句与 pt p; 意义相同。</p>
<p>这是个函数指针的声明，所指向的函数有两个 int* 参数，返回一个 int* 值，第二个参数是 int*， 整个函数返回一个 int*。</p>
<h2 id="typedef-和-define-的区别">typedef 和 #define 的区别</h2>
<p>前面已经简单介绍了 typedef 和 #define，二者都可以用来给对象取一个别名，但是两者却有着很大不同。</p>
<h4 id="1-执行时间不同">1. 执行时间不同</h4>
<p>关键字 typedef 是在<strong>编译阶段</strong>有效，因此 typedef 有类型检查的功能。</p>
<p>而 #define 则是宏定义，发生在<strong>预处理阶段</strong>，也就是编译阶段之前，它只进行简单而机械的字符串替换，而不进行任何检查。</p>
<h4 id="2-功能不同">2. 功能不同</h4>
<p>关键字 typedef 用来定义类型的别名，这些类型不只包含内部类型（int，char 等），还包括自定义类型（如 struct/class 定义的类型），可以起到使类型易于记忆的功能。如：</p>
<pre><code>typedef int (*pf) (const char*, const char*);
</code></pre>
<p>定义一个指向函数的指针的数据类型 pf，其中函数返回值为 int，两个参数都为 const char* 。</p>
<p>typedef 还有另一个重要用途：定义机器无关的类型，如可以定义一个叫 REAL 的浮点类型，在目标机器上它可以i获得最高的精度：</p>
<pre><code>typedef long double REAL;
</code></pre>
<p>在不支持 long double 的机器上，该 typedef 看起来会是下面这样：</p>
<pre><code>typedef double REAL;
</code></pre>
<p>甚至在连 double 都不支持的机器上，该 typedef 看起来会是这样：</p>
<pre><code>typedef float REAL;
</code></pre>
<p>而 #define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
<h4 id="3-作用域不同">3. 作用域不同</h4>
<p>#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。</p>
<p>而 typedef 有自己的作用域，如：</p>
<pre><code>void f()   
{   
    #define  A  int   
}    

void g()   
{   
    // 在这里也可以使用 A，因为宏替换没有作用域，   
    // 但如果上面用的是 typedef，那这里就不能用 A ，不过一般不在函数内使用 typedef
}
</code></pre>
<h4 id="4-对指针的操作">4. 对指针的操作</h4>
<p>二者在修饰指针类型时，作用不同。</p>
<pre><code>typedef int *pint；
#define PINT int *
const pint p；// p不可更改，p指向的内容可以更改，相当于int * const p;
const PINT p；// p可以更改，p指向的内容不能更改，相当于 const int *p；或 int const *p；
pint s1, s2;  // s1和s2都是int型指针
PINT s3, s4;  // 相当于int * s3，s4；只有一个是指针
</code></pre>
<h2 id="参考资料">参考资料</h2>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Typedef">wikipedia: typedef</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.cprogramming.com/tutorial/typedef.html">The Typedef Keyword in C and C++</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.cplusplus.com/doc/tutorial/other_data_types/">Other data types</a></p>
</blockquote>
<blockquote>
<p><a href="http://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions">stackoverflow: typedef struct vs struct definitions</a></p>
</blockquote>

    <div class = 'post_extra'><div class = 'copy' data-share = 'Share Story' data-copied = 'Link Copied'>
  <svg>
    <use xlink:href="#copy"></use>
  </svg>  
</div>

    </div>

  </article>
  <aside><h3>More from thinkerou</h3>
<ul class='posts aside'>
<li class = 'post_item'>
  <a class = 'post_card' href='https://thinkerou.com/post/c-macro/' title = '常见 C 语言宏使用记录' style = 'background-image: url(https://thinkerou.com/images/fast-lane.jpg);'>
  </a>
  <div class = 'excerpt'>
    <div class = 'excerpt_meta'>
      <a href = 'https://thinkerou.com/tags/c' class = 'post_tag'>C
      </a><div class = 'copy' data-share = 'Share Story' data-copied = 'Link Copied'>
  <svg>
    <use xlink:href="#copy"></use>
  </svg>  
</div>

    </div>
    <h3 class = 'post_link'>
      <a href='https://thinkerou.com/post/c-macro/'>常见 C 语言宏使用记录</a>
    </h3>
    <p class = 'pale'>1. 使用宏防止头文件被重复包含 #ifndef COMMON_DEFINE_H #define COMMON_DEFINE_H // 头文件相关内容 #endif  2. 使用宏 …</p>
  </div>
</li>

</ul>

  </aside>
</div>
<script src = 'https://thinkerou.com/js/autosize.min.js'></script>
<script src = 'https://thinkerou.com/js/timeago.js'></script>
    </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 699.428 699.428" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M502.714 0H240.428C194.178 0 153 42.425 153 87.429l-25.267.59c-46.228 0-84.019 41.834-84.019 86.838V612c0 45.004 41.179 87.428 87.429 87.428H459c46.249 0 87.428-42.424 87.428-87.428h21.857c46.25 0 87.429-42.424 87.429-87.428v-349.19zM459 655.715H131.143c-22.95 0-43.714-21.441-43.714-43.715V174.857c0-22.272 18.688-42.993 41.638-42.993l23.933-.721v393.429C153 569.576 194.178 612 240.428 612h262.286c0 22.273-20.765 43.715-43.714 43.715zm153-131.143c0 22.271-20.765 43.713-43.715 43.713H240.428c-22.95 0-43.714-21.441-43.714-43.713V87.429c0-22.272 20.764-43.714 43.714-43.714H459c-.351 50.337 0 87.975 0 87.975 0 45.419 40.872 86.882 87.428 86.882H612zm-65.572-349.715c-23.277 0-43.714-42.293-43.714-64.981V44.348L612 174.857zm-43.714 131.537H306c-12.065 0-21.857 9.77-21.857 21.835s9.792 21.835 21.857 21.835h196.714c12.065 0 21.857-9.771 21.857-21.835 0-12.065-9.792-21.835-21.857-21.835zm0 109.176H306c-12.065 0-21.857 9.77-21.857 21.834 0 12.066 9.792 21.836 21.857 21.836h196.714c12.065 0 21.857-9.77 21.857-21.836 0-12.064-9.792-21.834-21.857-21.834z"
    ></path>
  </symbol>
  <symbol viewBox="0 0 60.015 60.015" xmlns="http://www.w3.org/2000/svg" id="reply">
    <path d="M42.007 0h-24c-9.925 0-18 8.075-18 18v14c0 9.59 7.538 17.452 17 17.973v8.344a1.694 1.694 0 0 0 1.699 1.698c.44 0 .873-.173 1.198-.498l1.876-1.876C26.708 52.713 33.259 50 40.227 50h1.78c9.925 0 18-8.075 18-18V18c0-9.925-8.075-18-18-18zm16 32c0 8.822-7.178 16-16 16h-1.78c-7.502 0-14.556 2.921-19.86 8.226l-1.359 1.359V44a1 1 0 1 0-2 0v3.949c-8.356-.52-15-7.465-15-15.949V18c0-8.822 7.178-16 16-16h24c8.822 0 16 7.178 16 16v14z"></path>
  </symbol>
</svg>
<footer class = 'footer'>
  <div class = 'footer_inner wrap pale'>
    <p>&copy;&nbsp;<span class = 'year'></span>&nbsp;thinkerou.
    Designed by  <a href = 'https://github.com/thinkerou' title = 'Linkedin Profile'>thinkerou</a></p>
  </div>
</footer>
<script src = 'https://thinkerou.com/js/index.min.6f1e15baf1bfc7bd8fef3888ed12b61dbfe9bae77f3b2d13081b506d3845498ce50ecd52ea2bd050cc6abd234571aa92ae756910d8e032f623706e12b0d65e07.js'></script>

  </body>
</html>
